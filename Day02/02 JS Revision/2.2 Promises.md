# 2.2 Promises[ 04/09/2025 ]

---

## Callback Hell:

- Callback Hell is essentially nested callbacks [stacked below one another forming a pyramid structure]
    - where Every callback depends/waits for the previous callback,
    - thereby making a pyramid structure that "affects the readability and maintainability" of the code.

```jsx
setTimeout(() => {
    console.log("1st callback executed after 2s");
    setTimeout(() => {
        console.log("2nd callback executed after 3s, i.e., after Total 2+3 = 5s");
        setTimeout(() => {
            console.log("3rd callback executed after 4s, i.e., after Total 2+3+4 = 9s");
        }, 4000)
    }, 3000)
},2000)
```

## Promises

- A **Promise** is an object that represents the **eventual completion (or failure)** of an asynchronous operation and its resulting value.
- A promise can be in one of **three states**:
    1. **Pending** â€“ The initial state; the operation is still ongoing.
    2. **Fulfilled** â€“ The operation completed successfully, and the promise has a result.
    3. **Rejected** â€“ The operation failed, and the promise has an error.
- Promise basically represents a pending state that must be fulfilled/rejected at some point later
- Promises are used to handle asynchronous operations in JavaScript. [ same as Callbacks ]
    - But The promise pattern was created to replace the use of callbacks in certain situations. [ where callback creates callback hell ]
    - Promises make asynchronous code easier to write and understand.
    - Whereas Callback hell makes code hard to read and maintain

Syntax:

```jsx
let promise = new Promise(function(resolve, reject){
    //do something
});
```

- The promise constructor takes only 1 argument which is a "callback" function
- The callback function takes two arguments â†’ "resolve" and "reject"
    - If the callback fn is executed successfully, then "resolve" fn is called
    - If the callback fn is executed un-successfully, then "reject" fn is called
- To handle the Promise object
    - you need to chain the function call with the then() and catch()

```jsx
const promise1 = new Promise(function (resolve, reject) {
    setTimeout(() => {
        console.log("promise1's Async task is completed after 2s");
    },2000)
})

promise1.then(function() {
    console.log("Promise1 is fulfilled");
})
```

- Here, if we observe, `then()` is not executed.
- Why..?
    - The resolve() function corresponds to the then() function && reject() corresponds to the catch() function.
    - Those couples are interlinked.
    - in order to execute `.then()`, we need to invoke resolve() && to execute `.catch()`, we need to invoke reject()

```jsx
new Promise(function (resolve, reject) {
    setTimeout(() => {
        console.log("Promise2's async task is completed after 2s");
        resolve("Promise2 is fulfilled");
    }, 2000)
}).then((data) => {
    console.log(data);
})
```

NOTE:

- Whatever the function arguments passed in resolve & reject functions inside the promise object
    - the same arguments will be passed in `.then()` & `.catch()` callback functions
- `.finally()` can be used as default method & is called when promise is either fulfilled (or) rejected.
    - finally won't expect any arguments in it's callback fn.
    - Finally Block will **always run**, regardless of success or failure.
- we can have as many as `.then()` methods for the same promise object â†’ Promise Chaining

```jsx
const promise3 = new Promise(function (resolve, reject) {
    let error = false;
    setTimeout(() => {
        if(!error) {
            console.log("Promise3's async task is completed after 2s");
            resolve({username:"kumarjallipalli", email:"kumar@example.com"});
        }
        else {
            console.log("Promise3's async task is failed after 2s");
            reject({erorrtype:"Runtime Error", errormsg:"Promise Rejected"});
        }
    }, 2000)
})

promise3.then((data) => {
    console.log(`name: ${data.username} && mail: ${data.email}`);
    return data.username;
}).then((data) => {
    console.log(data);
}).catch((e)=>{
    console.log(`errorType: ${e.erorrtype} && msg: ${e.errormsg}`);
}).finally(() => {
    console.log("Always executed");
})

// "Promise3's async task is completed after 2s"
// "name: Paris && mail: Paris@example.com"
// "Paris"
// "Always executed"
```

```jsx
const promise3 = new Promise(function (resolve, reject) {
    let error = true;
    setTimeout(() => {
        if(!error) {
            console.log("Promise3's async task is completed after 2s");
            resolve({username:"kumarjallipalli", email:"kumar@example.com"});
        }
        else {
            console.log("Promise3's async task is failed after 2s");
            reject({erorrtype:"Runtime Error", errormsg:"Promise Rejected"});
        }
    }, 2000)
})

promise3.then((data) => {
    console.log(`name: ${data.username} && mail: ${data.email}`);
    return data.username;
}).then((data) => {
    console.log(data);
}).catch((e)=>{
    console.log(`errorType: ${e.erorrtype} && msg: ${e.errormsg}`);
}).finally(() => {
    console.log("Always executed");
})

// "Promise3's async task is failed after 2s"
// "errorType: Runtime Error && msg: Promise Rejected"
// "Always executed"
```

```jsx
// refactoring the callback hell code in promises
new Promise((resolve) => {
    setTimeout(() => {
        console.log("1st callback executed after 2s");
        resolve();
    },3000)
}).then(() => {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("2nd callback executed after 5s");
            resolve();
        },4000)
    })
}).then(() => {
    setTimeout(() => {
        console.log("3rd callback executed after 9s");
    },5000)
})
```

<aside>
ðŸ’¡

NOTE:

---

When to use callbacks & promises..?
 *      - Even promises use callbacks inside the then() and catch() methods.
 *      - Promises are used when you need to wait for a certain task to finish before running the next process.
 *      - you can use callbacks when your code doesn't have to wait for certain processes to finish. [ like forEach() ]

</aside>

## Promise Methods

```jsx
const p1 = Promise.resolve('Success');
const p2 = Promise.resolve(200);
const p3 = Promise.resolve('Finished');

// individual promises
p1.then((response) => {
    console.log(response);
})
p2.then((response) => {
    console.log(response);
})
p3.then((response) => {
    console.log(response);
})

// case-1: promise chaining --> we move to next response only if current response is obtained/executed
// ANd we can't get all the 3 promises responses together
p1.then((response1) => {
    console.log(response1);
    return p2
}).then((response2) => {
    console.log(response2);
    return p3
}).then((response3) => {
    console.log(response3);
})

// case-2: promise nesting --> All 3 promises executed at same time & getting all 3 responses together to use them
p1.then((response1) => {
    console.log(response1, "2");
    return p2.then((response2) => {
        console.log(response2, "2");
        return p3.then((response3) => {
            console.log(response3, "2");
            return [response1, response2, response3]
        })
    })
})
.then((array) => {
    console.log(array);
})

/**
 *  - But, This promise nesting is similar to callback hell
 *  - Hence, we want to avoid it.
 *  - So, JS provides us with few methods to deal these kind of scenarios
*/

Promise.all([p1, p2, p3])
.then( (response) => {
    console.log(response);
})
.catch( (reject) => {
    console.log(reject);
})

/**
 *  Promise.all():
 *  --------------
 *      - The Promise.all() method accepts an array of promises, and 
 *      - when all promises are resolved 
 *              --> will pass the responses returned by the each promise as an array and pass it to the then() method.
 *      - If one of the promises is rejected, 
 *              --> will returns the first reject it encounters and stops any further process
 * 
 * NOTE:
 *          - It takes promises as an array 
 *          - It returns the each promise's response as an array [in the same order of promise array]
 *          - this response array is passed to .then() [since response is array, then recives an array]
*/

/**
 *  Promise.allSettled():
 *  ---------------------
 *      - The Promise.allSettled() method is similar to the Promise.all() method, 
 *      - but instead of proceeding to catch() when one of the promises got rejected, 
 *      - this method will store the reject result and continue processing other promises.
 *      - When all promises are settled, method will return an "array of objects" that contains details of each promise.
*/

let p7 = Promise.reject('Error From Promise One');
let p8 = Promise.resolve(200);
let p9 = Promise.resolve('Finished');

Promise.allSettled([p7, p8, p9]).then(response => {
  console.log(response);
});
// // O/P
// [
//     { status: 'rejected', reason: 'Error From Promise One' },
//     { status: 'fulfilled', value: 200 },
//     { status: 'fulfilled', value: 'Finished' }
// ]

/**
 *  Promise.any():
 *  -------------
 *      - The Promise.any() method is similar to the Promise.all() method, 
 *      - except that it "returns only a single value" from any promise that calls the "resolve()" function first. 
 * 
 *  Promise.race():
 *  ---------------
 *      - The Promise.race() method is like the Promise.any() method, 
 *      - with one difference: the promise is settled when any promise is "either resolved or rejected:"
*/
```