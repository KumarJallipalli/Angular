# 2.3 Async Await [ 04/09/2025 ]

---

<aside>
ðŸ’¡

NOTE:

---

- We made Promises to handle Callback Hell â†’ nested Callbacks
- But, Promises use `.then()`, `.catch()`, and Methods chaining,
    - This sometimes **can get messy**, especially with multiple asynchronous
    - Makes it harder to follow & read the code
- Hence, Async & Await are introduced
</aside>

## Async & Await

- `async` and `await` are **syntactic sugar** over Promises.
- `async` and `await` didnâ€™t replace Promises, But are built on top of them.
- `async` and `await`  syntax allows you to handle promises without using method chaining
- `async` and `await` make asynchronous code **look and behave like synchronous code**, making it easier to write and read.
- `await`:
    - await keyword pauses the function execution **until the promise is resolved or rejected**.
        - Hence `async` and `await` make asynchronous code **look and behave like synchronous code**
        - But in reality, code execution doesnâ€™t pauses â†’ Non Blocking
    - `await` can only be used **inside an async function**.
        - Hence `async` keyword is introduced
- `async`:
    - The keyword async before a function makes the function asynchronous
        - And that function **always returns a promise**.
        - Even if you return a simple value, it will be wrapped in a promise.
        - Hence, we can still use `.then()` and `.catch()` methods [ on the returned value of async function ]

```jsx
// Async function
async function greet() {
  return "Hello!";
}

greet().then(msg => console.log(msg)); // Output: Hello!

// this throws error [ As await can only be used **inside an async function**. && NO Async function ]
const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
const json = await response.json();
console.log(json)

// Async function with Await
async function getData() {
  let response = await fetch('https://api.example.com/data');
  let data = await response.json();
  console.log(data);
}
getData();
```

```jsx
// handling promises using both then/catch & async/await
const promise3 = new Promise(function (resolve, reject) {
    let error = true;
    setTimeout(() => {
        if(!error) {
            console.log("Promise3's async task is completed after 2s");
            resolve({username:"kumarjallipalli", email:"kumar@example.com"});
        }
        else {
            console.log("Promise3's async task is failed after 2s");
            reject({erorrtype:"Runtime Error", errormessage:"Promise Rejected"});
        }
    }, 2000)
})

// using then/catch
promise3.then((data) => {
    console.log(`name: ${data.username} && mail: ${data.email}`);
    return data.username;
}).then((data) => {
    console.log(data);
}).catch((e)=>{
    console.log(`errorType: ${e.erorrtype} && mail: ${e.errormessage}`);
}).finally(() => {
    console.log("Always executed");
})

// using async/await
async function handlingPromise3 () {
    try {
        let resolve = await promise3;
        console.log(resolve.username);
        console.log(resolve.email);
    } catch (error) {
        console.log(`errorType2: ${error.erorrtype} && mail2: ${error.errormessage}`);
    }
}
// handlingPromise3()
console.log(handlingPromise3());
```

<aside>
ðŸ’¡

NOTE:

---

- To use then/catch, we need promise's response/reject => we definitely need a promise
- To use await, we definitely need an async function
</aside>

## fetch()

- **`fetch()`** is a built-in JavaScript function used to make **HTTP requests** (like `GET`, `POST`, etc.) to a **server** or **API**.
- It is a successor to `"XMLHTTPRequest()"`
- The Fetch API always returns a Promise object.
    - Hence, we can handle it using then/catch (or) async/await

fetch() functionality is divided into 2 parts:

1. browser/node â†’ will take care of all the network calls & returns the response from web
2. global memory â†’ this will store the fetch data once it get's as a response
    - This response from web is stored in an array called onFulfilled[]/onRejected[] based on fetch
    - Now this data stored in the array is being returned by fetch() method

NOTE:

- A fetch() promise only rejects when the request fails [ like bas URL or network issue ]
- A fetch() promise does not reject if server responds with status codes that indicate errors (404, 504, etc.)
- Simply, if connection is failed --> promise reject || else, promise response
- Hence, You must check `response.ok` to see if it was successful:

<aside>
ðŸ’¡

NOTE:

---

If you were using a `fetch()` alongside Promises, `fetch()` would be handled **after these promises**, 

because:

- `fetch()` is a **macro task** (placed in the task queue after the microtasks).
- Microtasks (like `.then()` handlers) run **before** any macro tasks.
</aside>